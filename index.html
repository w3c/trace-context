<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>
  <title>Trace Context</title>
  <script src='https://www.w3.org/Tools/respec/respec-w3c' class='remove' defer></script>
  <script class='remove'>
    var respecConfig = {
      specStatus: "ED",
      implementationReportURI: "https://w3c.github.io/trace-context/implementations",
      /* previousMaturity: "CR",
      previousPublishDate : "2019-08-13",
      crEnd: "2019-10-08",*/
      editors: [{
        name: "Sergey Kanzhelev",
        company: "Google",
        companyURL: "https://google.com",
        w3cid: "103966"
      },
      {
        name: "Daniel Dyla",
        company: "Dynatrace",
        companyURL: "https://dynatrace.com",
        w3cid: "117848"
      },
      {
        name: "Yuri Shkuro",
        company: "Meta",
        w3cid: "104074"
      },
      {
        name: "J. Kalyana Sundaram",
        company: "Microsoft",
        w3cid: "129894"
      },
      {
        name: "Bastian Krol",
        company: "Dash0",
        w3cid: "127244"
      }],
      formerEditors:  [{
        name: "Nik Molnar",
        w3cid: "104238"
      },
      {
        name: "Alois Reitbauer",
        w3cid: "48276"
      },
      {
        name: "Morgan McLean",
        w3cid: "104128"
      },
      {
        name: "Bogdan Drutu",
        w3cid: "104091"
      },
      {
        name: "Daniel Khan",
        w3cid: "90530"
      }],
      github: {
        repoURL: "https://github.com/w3c/trace-context/",
        branch: "main",
      },
      edDraftURI: "https://w3c.github.io/trace-context/",
      shortName: "trace-context",
      level: 3,
      format: "markdown",
      subjectPrefix: "trace-context",
      group: "distributed-tracing",
      wgPublicList: "public-trace-context",
      otherLinks: [{
        key: 'Discussions',
        data: [{
          value: 'We are on Slack.',
          href: 'https://w3cdistributedtracing.slack.com/'
        }]
      }],
      localBiblio: {
            "BIT-FIELD": {
              title: "8-bit field",
              href: "https://en.wikipedia.org/wiki/Bit_field",
              publisher: "Wikipedia"
            }
      }
    };
  </script>
</head>

<body>
  <section id='abstract' data-include="spec/01-abstract.md" data-include-format='markdown'></section>
  <section id='sotd' data-include="spec/02-sotd.md" data-include-format='markdown'></section>

  <section id='conformance'></section>

  <section data-include="spec/10-overview.md" data-include-format='markdown'></section>

  <section><h2>Trace Context HTTP Request Headers Format</h2>
    <p>This section describes the binding of the [=distributed trace=] context to `traceparent` and `tracestate` HTTP headers.</p>
    <section><h3>Relationship Between the Headers</h3>
      <p>The `traceparent` request header represents the incoming request in a tracing system in a common format, understood by all vendors. Here’s an example of a `traceparent` header.</p>
      <pre class="http">
        traceparent: 00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01
      </pre>
      <p>The `tracestate` request header includes the parent in a potentially vendor-specific format:</p>
      <pre class="http">
        tracestate: congo=t61rcWkgMzE
      </pre>
      <p>For example, say a client and server in a system use different tracing vendors: Congo and Rojo. A client traced in the Congo system adds the following headers to an outbound HTTP request.</p>
      <pre class="http">
        traceparent: 00-0af7651916cd43dd8448eb211c80319c-b7ad6b7169203331-01
        tracestate: congo=t61rcWkgMzE
      </pre>
      <p><strong>Note:</strong> In this case, the `tracestate` value `t61rcWkgMzE` is the result of Base64 encoding the parent ID (`b7ad6b7169203331`), though such manipulations are not required.</p>
      <p>The receiving server, traced in the Rojo tracing system, carries over the `tracestate` it received and adds a new entry to the left.</p>
      <pre class="http">
        traceparent: 00-0af7651916cd43dd8448eb211c80319c-00f067aa0ba902b7-01
        tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE
      </pre>
      <p>You'll notice that the Rojo system reuses the value of its `traceparent` for its entry in `tracestate`. This means it is a generic tracing system (no proprietary information is being passed). Otherwise, `tracestate` entries are [=opaque=] and can be vendor-specific.</p>
      <p>If the next receiving server uses Congo, it carries over the `tracestate` from Rojo and adds a new entry for the parent to the left of the previous entry.</p>
      <p><strong>Note:</strong> `ucfJifl5GOE` is the Base64 encoded parent ID `b9c7c989f97918e1`.</p>
      <p>Notice when Congo wrote its `traceparent` entry, it is not encoded, which helps in consistency for those doing correlation. However, the value of its entry `tracestate` is encoded and different from `traceparent`. This is ok.</p>
      <p>Finally, you'll see `tracestate` retains an entry for Rojo exactly as it was, except pushed to the right. The left-most position lets the next server know which tracing system corresponds with `traceparent`. In this case, since Congo wrote `traceparent`, its `tracestate` entry should be left-most.</p>
    </section>
    <section><h3>Traceparent Header</h3>
      <p>The `traceparent` HTTP header field identifies the incoming request in a tracing system. It has four fields:</p>
      <ul>
        <li>`version`</li>
        <li>`trace-id`</li>
        <li>`parent-id`</li>
        <li>`trace-flags`</li>
      </ul>
      <section><h4>Header Name</h4>
        <p>Header name: `traceparent`</p>
        <p data-cite="infra">The header name is [=ASCII case-insensitive=]. That is, `TRACEPARENT`, `TraceParent`, and `traceparent` are considered the same header. The header name is a single word; it does not contain any delimiters such as a hyphen.</p>
        <p data-cite="infra">In order to increase interoperability across multiple protocols and encourage successful integration, tracing systems SHOULD encode the header name as [=ASCII lowercase=].</p>
      </section>
      <section><h4>traceparent Header Field Values</h4>
        <p>This section uses the Augmented Backus-Naur Form (ABNF) notation of [[!RFC5234]], including the DIGIT rule from that document. The `DIGIT` rule defines a single number character `0`-`9`.</p>
        <pre class="ABNF">
          HEXDIGLC = DIGIT / "a" / "b" / "c" / "d" / "e" / "f" ; lowercase hex character
          value           = version "-" version-format
        </pre>
        <p>The dash (`-`) character is used as a delimiter between fields.</p>
        <section><h5>version</h5>
          <pre class="ABNF">
            version         = 2HEXDIGLC   ; this document assumes version 00. Version ff is forbidden
          </pre>
          <p>Version (`version`) is an 8-bit unsigned integer value, serialized as an ASCII string with two characters. Version 255 (`"ff"`) is invalid. This document specifies version 0 (`"00"`) of the `traceparent` header.</p>
        </section>
        <section><h5>version-format</h5>
          <p>The following `version-format` definition is used for version `00`.</p>
          <pre class="ABNF">
            version-format   = trace-id "-" parent-id "-" trace-flags
            trace-id         = 32HEXDIGLC  ; 16 bytes array identifier. All zeroes forbidden
            parent-id        = 16HEXDIGLC  ; 8 bytes array identifier. All zeroes forbidden
            trace-flags      = 2HEXDIGLC   ; 8 bit flags.
          </pre>
        </section>
        <section><h4>trace-id</h4>
          <p>This is the ID of the whole trace forest and is used to uniquely identify a [=distributed trace=] through a system. It is represented as a 16-byte array, for example, `4bf92f3577b34da6a3ce929d0e0e4736`. All bytes as zero (`00000000000000000000000000000000`) is considered an invalid value.</p>
          <p>The value of `trace-id` SHOULD be globally unique. One recommended method to ensure global uniqueness, as well as to address some privacy and security considerations, to a satisfactory degree of certainty is to randomly (or pseudo-randomly) generate the `trace-id`. Implementers SHOULD use a `trace-id` generation method which randomly (or pseudo-randomly) generates at least the right-most 7 bytes of the ID. If the right-most 7 bytes are randomly (or pseudo-randomly) generated, the corresponding [[[#random-trace-id-flag]]] SHOULD be set. For more details, see [[[#considerations-for-trace-id-field-generation]]].</p>
          <p>If the `trace-id` value is invalid (for example if it contains non-allowed characters or all zeros), vendors MUST ignore the entire header.</p>
        </section>
        <section><h4>parent-id</h4>
          <p>This is the ID of this request as known by the caller (in some tracing systems, this is known as the `span-id`, where a `span` is the execution of a client request). It is represented as an 8-byte array, for example, `00f067aa0ba902b7`. All bytes as zero (`0000000000000000`) is considered an invalid value.</p>
          <p>Vendors MUST ignore the `traceparent` when the `parent-id` is invalid (for example, if it contains non-lowercase hex characters).</p>
        </section>
        <section><h4>trace-flags</h4>
          <p>This is an <a data-cite='!BIT-FIELD#firstHeading'>8-bit field</a> that controls tracing flags such as sampling, trace level, etc. These flags are recommendations given by the caller rather than strict rules to follow for three reasons:</p>
          <ol>
            <li>An untrusted caller may be able to abuse a tracing system by setting these flags maliciously.</li>
            <li>A caller may have a bug which causes the tracing system to have a problem.</li>
            <li>Different load between caller service and callee service might force callee to downsample.</li>
          </ol>
          <p>You can find more in the section [[[#security-considerations]]] of this specification.</p>
          <p>Like other fields, `trace-flags` is hex-encoded. For example, all `8` flags set would be `ff` and no flags set would be `00`.</p>
          <p>As this is a bit field, the flags cannot be interpreted by a simple equality comparison. For example, both `01` (`00000001`) and `03` (`00000011`) represent that the trace has been sampled because the sampled flag (`00000001`) is set, and `03` and `02` (`00000010`) both represent that at least the right-most 7 bytes of the `trace-id` are randomly (or pseudo-randomly) generated because the random bit (`00000010`) is set. A common mistake when interpreting bit-fields is using a comparison of the whole number rather than interpreting a single bit.</p>
          <p>Here is an example of properly handling trace flags:</p>
          <pre class="java">
            static final byte FLAG_SAMPLED = 1; // 00000001
            static final byte FLAG_RANDOM = 2; // 00000010
            ...
            boolean sampled = (traceFlags & FLAG_SAMPLED) == FLAG_SAMPLED;
            boolean random = (traceFlags & FLAG_RANDOM) == FLAG_RANDOM;
          </pre>
          <section><h5>Sampled Flag</h5>
            <p>When set, the least significant bit (right-most), denotes that the caller may have recorded trace data. When unset, the caller did not record trace data out-of-band.</p>
            <p>There are a number of recording scenarios that may break distributed tracing:</p>
            
            <ul>
              <li>Only recording a subset of requests results in broken traces.</li>
              <li>Recording information about all incoming and outgoing requests becomes prohibitively expensive, at load.</li>
              <li>Making random or component-specific data collection decisions leads to fragmented data in all traces.</li>
            </ul>
            <p>Because of these issues, tracing vendors make their own recording decisions, and there is no consensus on what is the best algorithm for this job.</p>
            
            <p>Various techniques include:</p>
            <ul>
              <li>Probability sampling (sample 1 out of 100 [=distributed traces=] by flipping a coin)</li>
              <li>Delayed decision (make collection decision based on duration or a result of a request)</li>
              <li>Deferred sampling (let the callee decide whether information about this request needs to be collected)</li>
            </ul>
            <p>How these techniques are implemented can be tracing vendor-specific or application-defined.</p>
            
            <p>The `tracestate` field is designed to handle the variety of techniques for making recording decisions (or other specific information) specific for a given vendor. The `sampled` flag provides better interoperability between vendors. It allows vendors to communicate recording decisions and enable a better experience for the customer.</p>
            
            <p>For example, when a SaaS service participates in a [=distributed trace=], this service has no knowledge of the tracing vendor used by its caller. This service may produce records of incoming requests for monitoring or troubleshooting purposes. The `sampled` flag can be used to ensure that information about requests that were marked for recording by the caller will also be recorded by SaaS service downstream so that the caller can troubleshoot the behavior of every recorded request.</p>
            
            <p>The `sampled` flag has no restriction on its mutations except that it can only be mutated when [[[#parent-id]]] is updated.</p>
            
            <p>The following are a set of suggestions that vendors SHOULD use to increase vendor interoperability.</p>
            <ul>
              <li>If a component made definitive recording decision - this decision SHOULD be reflected in the `sampled` flag.</li>
              <li>If a component needs to make a recording decision - it SHOULD respect the `sampled` flag value. [[[#security-considerations]]] SHOULD be applied to protect from abusive or malicious use of this flag.</li>
              <li>If a component deferred or delayed the decision and only a subset of telemetry will be recorded, the `sampled` flag should be propagated unchanged. It should be set to `0` as the default option when the trace is initiated by this component.</li>
            </ul>
            <p>There are two additional options that vendors MAY follow:</p>
            
            <ul>
              <li>A component that makes a deferred or delayed recording decision may communicate the priority of a recording by setting `sampled` flag to `1` for a subset of requests.</li>
              <li>A component may also fall back to probability sampling and set the `sampled` flag to `1` for the subset of requests.</li>
            </ul>
          </section>
          <section><h5>Random Trace ID Flag</h5>
            <p>The second least significant bit of the trace-flags field denotes the `random-trace-id` flag.</p>
            <p>When starting or restarting a trace (that is, when the participant generates a new `trace-id`), the following rules apply:</p>
            <ul>
              <li>If that flag is set, at least the right-most 7 bytes of the `trace-id` MUST be selected randomly (or pseudo-randomly) with uniform distribution over the interval [0..2^56-1].</li>
              <li>If the flag is not set, the `trace-id` MAY still be randomly (or pseudo-randomly) generated.</li>
              <li>When unset, the `trace-id` MAY be generated in any way that satisfies the requirements of the [trace ID format](#trace-id).</li>
              <li>When at least the right-most 7 bytes of the `trace-id` are randomly (or pseudo-randomly) generated, the `random-trace-id` flag SHOULD be set to `1`.</li>
            </ul>
            <p>When continuing a trace (that is, the incoming HTTP request had the `traceparent` header and the participant uses the same `trace-id` in the `traceparent` header on outgoing requests), the following rules apply:</p>
            <ul>
              <li>If the flag is set in the incoming `traceparent` header, it MUST also be set in all outgoing `traceparent` headers which use the same `trace-id`.</li>
              <li>If the flag is unset in the incoming `traceparent` header, it MUST also be unset in any outgoing `traceparent` headers which use the same `trace-id`.</li>
            </ul>
            
            <p>This allows downstream consumers to implement features such as trace sampling or database sharding based on these bytes. For additional information, see [[[#considerations-for-trace-id-field-generation]]].</p>
          </section>
          <section><h5>Other Flags</h5>
            <p>The behavior of other flags, such as (`00000100`) is not defined and is reserved for future use. Vendors MUST set those to zero.</p>
          </section>
        </section>
      </section>
      <section><h4>Examples of HTTP traceparent Headers</h4>
        <p><i>Valid traceparent when caller sampled this request:</i></p>
        <pre>
        Value = 00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-01
        base16(version) = 00
        base16(trace-id) = 4bf92f3577b34da6a3ce929d0e0e4736
        base16(parent-id) = 00f067aa0ba902b7
        base16(trace-flags) = 01  // sampled
        </pre>
        
        <p><i>Valid traceparent when caller didn’t sample this request:</i></p>
        
        <pre>
        Value = 00-4bf92f3577b34da6a3ce929d0e0e4736-00f067aa0ba902b7-00
        base16(version) = 00
        base16(trace-id) = 4bf92f3577b34da6a3ce929d0e0e4736
        base16(parent-id) = 00f067aa0ba902b7
        base16(trace-flags) = 00  // not sampled
        </pre>
      </section>
      <section><h3>Versioning of Traceparent</h3>
        <p>This specification is opinionated about future versions of trace context. The current version of this specification assumes that future versions of the `traceparent` header will be additive to the current one.</p>
        <p>Vendors MUST follow these rules when parsing headers with an unexpected format:</p>
        <ul>
          <li>Pass-through services should not analyze the version. They should expect that headers may have larger size limits in the future and only disallow prohibitively large headers.</li>
          <li>When the version prefix cannot be parsed (it's not 2 hex characters followed by a dash (`-`)), the implementation should restart the trace.</li>
          <li>
            <p>If a higher version is detected, the implementation SHOULD try to parse it by trying the following:</p>
            <ul>
              <li>If the size of the header is shorter than 55 characters, the vendor should not parse the header and should restart the trace.</li>
              <li>Parse `trace-id` (from the first dash through the next 32 characters). Vendors MUST check that the 32 characters are hex, and that they are followed by a dash (`-`).</li>
              <li>Parse `parent-id` (from the second dash at the 35th position through the next 16 characters). Vendors MUST check that the 16 characters are hex and followed by a dash.</li>
              <li>Parse the `sampled` bit of `flags` (2 characters from the third dash). Vendors MUST check that the 2 characters are either at the end of the string or followed by a dash.</li>
            </ul>
            <p>If all three values were parsed successfully, the vendor should use them.</p>
          </li>
        </ul>
      </section>
    </section>
    <section><h3>Tracestate Header</h3>
      <p>The main purpose of the `tracestate` HTTP header is to provide additional vendor-specific trace identification information across different distributed tracing systems and is a companion header for the `traceparent` field. It also conveys information about the request’s position in multiple distributed tracing graphs.</p>
      <p>If the vendor failed to parse `traceparent`, it MUST NOT attempt to parse `tracestate`. Note that the opposite is not true: failure to parse `tracestate` MUST NOT affect the parsing of `traceparent`.</p>
      <p>The `tracestate` HTTP header MUST NOT be used for any properties that are not defined by a tracing system. [[BAGGAGE]] MAY be used for defining and propagating such application level properties.</p>
      <section><h4>Header Name</h4>
        <p>Header name: `tracestate`</p>
        <p data-cite="infra">The header name is [=ASCII case-insensitive=]. That is, `TRACESTATE`, `TraceState`, and `tracestate` are considered the same header. The header name is a single word, it does not contain any delimiters such as a hyphen.</p>
        <p data-cite="infra">In order to increase interoperability across multiple protocols and encourage successful integration, tracing systems SHOULD encode the header name as [=ASCII lowercase=].</p>
      </section>
      <section><h4>tracestate Header Field Values</h4>
        <p>The `tracestate` field may contain any [=opaque=] value in any of the keys. Tracestate MAY be sent or received as multiple header fields. Multiple tracestate header fields MUST be handled as specified by <a data-cite='!RFC9110#fields.order'>RFC9110 Section 5.3 Field Order</a>. The `tracestate` header SHOULD be sent as a single field when possible, but MAY be split into multiple header fields. When sending `tracestate` as multiple header fields, it MUST be split according to <a data-cite='!RFC9110#fields.order'>RFC9110</a>. When receiving multiple `tracestate` header fields, they MUST be combined into a single header according to <a data-cite='!RFC9110#fields.order'>RFC9110</a>.</p>
        <p>This section uses the Augmented Backus-Naur Form (ABNF) notation of [[!RFC5234]], including the DIGIT rule in <a data-cite='!RFC5234#appendix-B.1'>appendix B.1 for RFC5234</a>. It also includes the `OWS` rule from <a data-cite='!RFC9110#whitespace'>RFC9110 section 5.6.3</a>.</p>
        <p>The `DIGIT` rule defines numbers `0`-`9`.</p>
        <p>The `OWS` rule defines an optional whitespace character. To improve readability, it is used where zero or more whitespace characters might appear.</p>
        <p>The caller SHOULD generate the optional whitespace as a single space; otherwise, a caller SHOULD NOT generate optional whitespace. See details in the <a data-cite='!RFC9110#whitespace'>corresponding RFC</a>.</p>
        <p>The `tracestate` field value is a `list` of `list-members` separated by commas (`,`). A `list-member` is a key/value pair separated by an equals sign (`=`). Spaces and horizontal tabs surrounding `list-member`s are ignored. There can be a maximum of 32 `list-member`s in a `list`. If adding an entry would cause the `tracestate` list to contain more than 32 `list-members` the right-most `list-member` should be removed from the list.</p>
        <p>Empty and whitespace-only list members are allowed. Vendors MUST accept empty `tracestate` headers but SHOULD avoid sending them. Empty list members are allowed in `tracestate` because it is difficult for a vendor to recognize the empty value when multiple `tracestate` headers are sent. Whitespace characters are allowed for a similar reason, as some vendors automatically inject whitespace after a comma separator, even in the case of an empty header.</p>
        <section><h5>list</h5>
          <p>A simple example of a `list` with two `list-member`s might look like: `vendorname1=opaqueValue1,vendorname2=opaqueValue2`.</p>
          <pre class="ABNF">
            list  = list-member 0*31( OWS "," OWS list-member )
            list-member = (key "=" value) / OWS
          </pre>
          <p>Identifiers for a `list` are short (up to 256 characters) textual identifiers.</p>
        </section>
        <section><h5>list-members</h5>
          <p>A `list-member` contains a key/value pair.</p>
          <section><h6>Key</h6>
            <p>The key is an identifier that describes the vendor.</p>
            <pre class="ABNF">
                key = ( lcalpha / DIGIT ) 0*255 ( keychar )
                keychar    = lcalpha / DIGIT / "_" / "-"/ "*" / "/" / "@"
                lcalpha    = %x61-7A ; a-z
            </pre>
            <p>A `key` MUST begin with a lowercase letter or a digit and contain up to 256 characters including lowercase letters (`a`-`z`), digits (`0`-`9`), underscores (`_`), dashes (`-`), asterisks (`*`), forward slashes (`/`), and at signs (`@`).</p>
          </section>
          <section><h6>Value</h6>
            <p>The value is an [=opaque=] string containing up to 256 printable ASCII [[!RFC0020]] characters (i.e., the range 0x20 to 0x7E) except comma (,) and (=). The string must end with a character which is not a space (0x20). Note that this also excludes tabs, newlines, carriage returns, etc. All leading spaces MUST be preserved as part of the value. All trailing spaces are considered to be optional whitespace characters not part of the value. Optional trailing whitespace MAY be excluded when propagating the header.</p>
            <pre class="ABNF">
              value    = 0*255(chr) nblk-chr
              nblk-chr = %x21-2B / %x2D-3C / %x3E-7E
              chr      = %x20 / nblk-chr
            </pre>
          </section>
        </section>
      </section>
      <section><h4>Combined Header Values</h4>
        <p>The `tracestate` value is the concatenation of trace graph key/value pairs.</p>
        <p>Example: `vendorname1=opaqueValue1,vendorname2=opaqueValue2`</p>
        
        <p>Tracing tools are not supposed to add the same header multiple times. For example, if a vendor name is Congo and a trace started in their system and then went through a system named Rojo and later returned to Congo, the `tracestate` value would not be:</p>
        
        <p>`congo=congosFirstPosition,rojo=rojosFirstPosition,congo=congosSecondPosition`</p>
        
        <p>Instead, the entry would be rewritten to only include the most recent position: `congo=congosSecondPosition,rojo=rojosFirstPosition`</p>
        
        <p>See [[[#mutating-the-tracestate-field]]] for details.</p>
        <section><h5>tracestate Limits:</h5>
          <p>Vendors SHOULD propagate at least 512 characters of a combined header. This length includes commas required to separate list items and optional white space (`OWS`) characters.</p>
          <p>There are systems where propagating of 512 characters of `tracestate` may be expensive. In this case, the maximum size of the propagated `tracestate` header SHOULD be documented and explained. The cost of propagating `tracestate` SHOULD be weighted against the value of monitoring scenarios enabled for the end users.</p>
          <p>In a situation where `tracestate` is truncated due to the total size of the header value, the vendor MUST truncate whole entries. Entries larger than `128` characters long SHOULD be removed first. Then entries SHOULD be removed starting from the end of `tracestate`. Other truncation strategies like safe list entries, blocked list entries, or size-based truncation SHOULD NOT be used.</p>
        </section>
      </section>
      <section><h4>Examples of tracestate HTTP Headers</h4>
        <p>Single tracing system (generic format):</p>
        <pre class="http">
          tracestate: rojo=00f067aa0ba902b7
        </pre>
        <p>Multiple tracing systems (with different formatting):</p>
        <pre class="http">
          tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE
        </pre>
      </section>
      <section><h4>Versioning of tracestate</h4>
        <p>The version of `tracestate` is defined by the version prefix of `traceparent` header. Vendors need to attempt to parse `tracestate` if a higher version is detected, to the best of its ability. It is the vendor’s decision whether to use partially-parsed `tracestate` key/value pairs or not.</p>
      </section>
    </section>
    <section><h3>Mutating the traceparent Field</h3>
      <p>A vendor receiving a request without a `traceparent` header SHOULD generate `traceparent` headers for outbound requests, effectively starting a new trace. A possible reason for not doing this could be a performance sensitive scenario when the vendor decides to not sample a request. Note that for most scenarios, vendors are expected to generate the header even when not sampling, to propagate the sampling decision downstream.</p>
      <p>A vendor receiving a `traceparent` request header MUST send it to outgoing requests. It MAY mutate the value of this header before passing it to outgoing requests.</p>
      <p>If the value of the `traceparent` field wasn't changed before propagation, `tracestate` MUST NOT be modified as well. Unmodified header propagation is typically implemented in pass-through services like proxies. This behavior may also be implemented in a service which currently does not collect distributed tracing information.</p>
      <p>Following is the list of allowed mutations:</p>
      <ul>
        <li><strong>Update `parent-id`</strong>: The value of [the  parent-id field](#parent-id) can be set to the new value representing the ID of the current operation. This is the most typical mutation and should be considered a default.</li>
        <li><strong>Update `sampled`</strong>: The value of [the sampled field](#trace-flags) reflects the caller's recording behavior: either trace data was dropped or may have been recorded out-of-band. This can be indicated by toggling the flag in both directions. This mutation gives the downstream vendor information about the likelihood that its parent's information was recorded. The `parent-id` field MUST be set to a new value with the `sampled` flag update.</li>
        <li><strong>Restart trace</strong>: All properties (`trace-id`, `parent-id`, `trace-flags`) are regenerated. This mutation is used in services that are defined as a front gate into secure networks and eliminates a potential denial-of-service attack surface. Vendors SHOULD clean up `tracestate` collection on `traceparent` restart. There are rare cases when the original `tracestate` entries must be preserved after a restart. This typically happens when the `trace-id` is reverted back at some point of the trace flow, for instance, when it leaves the secure network. However, it SHOULD be an explicit decision, and not the default behavior.</li>
        <li><strong>Downgrade the version</strong>: This version of the specification (`00`) [defines the behavior](#version) for a vendor that receives a `traceparent` header of a higher version. In this case, the first mutation is to downgrade the version of the header. Other mutations are allowed in combination with this one.</li>
      </ul>
      <p>Vendors MUST NOT make any other mutations to the `traceparent` header.</p>
    </section>
    <section><h3>Mutating the tracestate Field</h3>
      <p>Vendors receiving a `tracestate` request header MUST send it to outgoing requests. It MAY mutate the value of this header before passing to outgoing requests. When mutating `tracestate`, the order of unmodified key/value pairs MUST be preserved. Modified keys MUST be moved to the beginning (left) of the list.</p>
      <p>Following are allowed mutations:</p>
      <ul>
        <li><strong>Add a new key/value pair</strong>: The new key/value pair SHOULD be added to the beginning of the list. Adding a key/value pair MUST NOT result in the same key being present multiple times.</li>
        <li><strong>Update an existing value</strong>: The value for any given key can be updated. Modified keys SHOULD be moved to the beginning (left) of the list.</li>
        <li><strong>Delete a key/value pair</strong>: Any key/value pair MAY be deleted. Vendors SHOULD NOT delete keys that were not generated by them. The deletion of an unknown key/value pair will break correlation in other systems. This mutation enables three scenarios. The first is that proxies can block certain `tracestate` keys for privacy and security concerns. The second scenario is a truncation of long `tracestate`s. Finally, vendors MAY also discard duplicate keys that were not generated by them.</li>
      </ul>
    </section>
  </section>

  <section data-include="spec/21-http_response_header_format.md" data-include-format='markdown'></section>

  <section class="informative" data-include="spec/30-processing-model.md" data-include-format='markdown'></section>

  <section data-include="spec/40-other-protocols.md" data-include-format='markdown'></section>

  <section data-include="spec/50-privacy.md" data-include-format='markdown'></section>
  <section data-include="spec/51-security.md" data-include-format='markdown'></section>

  <section class="informative" data-include="spec/60-trace-id-format.md" data-include-format='markdown'></section>
  <section class="informative" data-include="spec/61-span-id-format.md" data-include-format='markdown'></section>

  <section class="appendix" data-include="spec/60-acknowledgments.md" data-include-format='markdown'></section>

  <section class="informative">
    <h1>Glossary</h1>
    <dl>
    <dt><dfn data-lt="distributed traces">Distributed trace</dfn></dt>
    <dd>
      A distributed trace is a set of events, triggered as a result
      of a single logical operation, consolidated across various
      components of an application. A distributed trace contains
      events that cross process, network and security boundaries.
      A distributed trace may be initiated when someone presses a
      button to start an action on a website - in this example, the
      trace will represent calls made between the downstream services
      that handled the chain of requests initiated by this button
      being pressed.
    </dd>
    </dl>
    <dl>
    <dt><dfn data-lt="opaque">Opaque value</dfn></dt>
    <dd>
      An opaque value refers to a value that can only be understood
      or processed in any way by the distributed trace participant that generated
      this value. Any other participant must treat it as a blob of bytes.
    </dd>
    </dl>
  </section>

</body>

</html>
