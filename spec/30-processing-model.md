# Processing Model

This section provides a step-by-step example of a tracing vendor receiving a request with trace context headers, processing the request and then potentially forwarding it. This description can be used as a reference when implementing a trace context-compliant tracing system, middleware (like a proxy or messaging bus), or a cloud service.

## Processing Model for Working with Trace Context Request Header

This processing model describes the behavior of a vendor that modifies and forwards trace context headers. How the model works depends on whether or not a `traceparent` header is received.

### No traceparent Received

If no traceparent header is received:

1. The vendor checks an incoming request for a `traceparent` and a `tracestate` header.
2. Because the `traceparent` header is not received, the vendor creates a new `trace-id` and `parent-id` that represents the current request. (Note: If the vendor does not sample this request and wants to communicate that sampling decision downstream via the `sampled` flag, the vendor MAY create a `trace-id` and `parent-id` that are not associated with any actual trace data. The vendor MAY also decide to not communicate the sampling decision downstream.)
3. If a `tracestate` header is received without an accompanying `traceparent` header, it is invalid and MUST be discarded.
4. The vendor SHOULD create a new `tracestate` header and add a new key/value pair.
5. The vendor sets the `traceparent` and `tracestate` header for the outgoing request.

### A traceparent is Received

If a `traceparent` header is received:

1. The vendor checks an incoming request for a `traceparent` and a `tracestate` header.
2. Because the `traceparent` header _is present_, the vendor tries to parse the version of the `traceparent` header.
    1. If the _version cannot be parsed_, the vendor creates a new `traceparent` header and deletes `tracestate`.
    2. If the _version number is higher_ than supported by the tracer, the vendor uses the format defined in this specification (`00`) to parse `trace-id` and `parent-id`.
The vendor will only parse the `trace-flags` values supported by this version of this specification and ignore all other values. If parsing fails, the vendor creates a new `traceparent` header and deletes the `tracestate`. Vendors will set all unparsed / unknown `trace-flags` to 0 on outgoing requests.
    3. If the vendor _supports the version number_, it validates `trace-id` and `parent-id`. If either `trace-id`, `parent-id` or `trace-flags` are invalid, the vendor creates a new `traceparent` header and deletes `tracestate`.
3. The vendor MAY validate the `tracestate` header. If the `tracestate` header cannot be parsed the vendor MAY discard the entire header. Invalid `tracestate` entries MAY also be discarded.
4. For each outgoing request the vendor performs the following steps:
     1. The vendor MUST modify the `traceparent` header:
        * **Update `parent-id`:** The value of property `parent-id` MUST be set to a value representing the ID of the current operation.
        * **Update `sampled`:** The value of `sampled` reflects the caller's recording behavior. The value of the `sampled` flag of `trace-flags` MAY be set to `1` if the trace data is likely to be recorded or to `0` otherwise. Setting the flag is no guarantee that the trace will be recorded but increases the likeliness of end-to-end recorded traces.

     2. The vendor MAY modify the `tracestate` header:
        * **Update a key value:** The value of any key can be updated. Modified keys MUST be moved to the beginning (left) of the list.
        * **Add a new key/value pair:** The new key-value pair MUST be added to the beginning (left) of the list.
        * **Delete a key/value pair:** Any key/value pair MAY be deleted. Vendors SHOULD NOT delete keys that weren't generated by themselves. Deletion of any key/value pair MAY break correlation in other systems.
     3. The vendor sets the `traceparent` and `tracestate` header for the outgoing request.

### Alternative Processing

The processing model above describes the complete set of steps for processing trace context headers. There are, however, situations when a vendor might only support a subset of the steps described above. Proxies or messaging middleware MAY decide not to modify the `traceparent` headers but remove invalid headers or add additional information to `tracestate`.

## Processing Model for Working with Trace Context Response Header

This processing model describes the behavior of a tracing system that returns trace context headers. Behavior depends on the configuration of the tracing system and what information it wishes to return to the caller.

### Restarted Trace

When a service is called by an untrusted third party, it may decide to restart the trace. In this case, the called service MAY return a `traceresponse` field indicating its internal `trace-id`, `span-id`, and sampling decision.

Example request and response:

Request
```http
traceparent: 00-4bf92f3577b34da6a3ce929d0e0e4736-d75597dee50b0cac-01
```
Response
```http
traceresponse: 00-1baad25c36c11c1e7fbd6d122bd85db6-cab70b47728a8a99-01
```

In this example, a participant in a trace with ID `4bf92f3577b34da6a3ce929d0e0e4736` calls a third party system that collects their own internal telemetry using a new trace ID `1baad25c36c11c1e7fbd6d122bd85db6`. When the third party completes its request, it returns the new trace ID, the ID of the operation, and internal sampling decision to the caller. If there is an error with the request, the caller can include the third party's internal trace ID in a support request.

### Load Balancer Deferred Sampling

When a service initially makes the decision to _not_ sample a particular request, and also makes an outbound call to another downstream service, there may be some event during the processing of that request which causes the downstream service to decide to sample after all. In this case, the downstream service may return its updated sampling decision to the caller via the `traceresponse` header. Based on this, the caller may change its sampling decision and in turn also return its updated sampling decision to its caller, and so on. In this way, as much of a trace as possible may be recovered for troubleshooting purposes even if the original sampling decision was negative.

One example of this might be a load balancer which samples a random subset of requests. If the destination service encounters a problem, it may indicate that the request should be sampled by the load balancer anyway by returning a `traceresponse` with the sampled flag set.

Example request and response:

Request
```http
traceparent: 00-4bf92f3577b34da6a3ce929d0e0e4736-d75597dee50b0cac-00
```
Response
```http
traceresponse: 00-4bf92f3577b34da6a3ce929d0e0e4736-828c5d0d435ba505-01
```

In this example, a caller (the load balancer) in a trace with ID `4bf92f3577b34da6a3ce929d0e0e4736` wishes to defer a sampling decision to its callee. When the callee completes the request, it returns its sampling decision to the caller.
